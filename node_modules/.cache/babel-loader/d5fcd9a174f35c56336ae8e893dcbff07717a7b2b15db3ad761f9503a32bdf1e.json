{"ast":null,"code":"function calculateDistance(point1, point2) {\n  const deltaX = point2.x - point1.x;\n  const deltaY = point2.y - point1.y;\n  const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n  return distance;\n}\nexport default function polygonArea(coordsarray) {\n  let area = 0;\n  /*  let j = coords.length - 1;\n  \n    for (let i = 0; i < coords.length; i++) {\n        area += (coords[j].x + coords[i].x) * (coords[j].y - coords[i].y);\n        j = i;\n    }\n  \n    return Math.abs(area / 2);\n  \n  \n  let highestY=0;\n  let secondHighestY=0;\n  for (let i=1;i<yArr.length;i++){\n    if(yArr[i]>yArr[highestY]){\n      highestY=i;\n    }\n  }\n  for (let i=0;i<yArr.length;i++){\n    if(yArr[i]>yArr[secondHighestY]&&yArr[i]<yArr[highestY]){\n      secondHighestY=i;\n    }\n  }\n  */\n  coordsarray.sort((a, b) => b.y > a.y);\n  console.log(coordsarray);\n  const edge1 = calculateDistance(coordsarray[1], coordsarray[0]);\n  const edge2 = calculateDistance(coordsarray[2], coordsarray[1]);\n  area = edge1 * edge2;\n  console.log(edge1, edge2, area);\n  return area / 100;\n}","map":{"version":3,"names":["calculateDistance","point1","point2","deltaX","x","deltaY","y","distance","Math","sqrt","polygonArea","coordsarray","area","sort","a","b","console","log","edge1","edge2"],"sources":["/Users/akriti/workspace/portfolio/portfolio/src/SolarChecker/Utilities/polygonArea.js"],"sourcesContent":["\nfunction calculateDistance(point1, point2) {\n  const deltaX = point2.x - point1.x;\n  const deltaY = point2.y - point1.y;\n  const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n  return distance;\n}\n\nexport default function polygonArea(coordsarray) {\n  let area = 0;\n/*  let j = coords.length - 1;\n\n  for (let i = 0; i < coords.length; i++) {\n      area += (coords[j].x + coords[i].x) * (coords[j].y - coords[i].y);\n      j = i;\n  }\n\n  return Math.abs(area / 2);\n\n\nlet highestY=0;\nlet secondHighestY=0;\nfor (let i=1;i<yArr.length;i++){\n  if(yArr[i]>yArr[highestY]){\n    highestY=i;\n  }\n}\nfor (let i=0;i<yArr.length;i++){\n  if(yArr[i]>yArr[secondHighestY]&&yArr[i]<yArr[highestY]){\n    secondHighestY=i;\n  }\n}\n*/\ncoordsarray.sort((a,b)=>b.y>a.y);\nconsole.log(coordsarray);\nconst edge1=calculateDistance(coordsarray[1],coordsarray[0]);\nconst edge2=calculateDistance(coordsarray[2],coordsarray[1]);\narea= edge1*edge2;\nconsole.log(edge1, edge2, area);\n  return area/100;\n}\n"],"mappings":"AACA,SAASA,iBAAiBA,CAACC,MAAM,EAAEC,MAAM,EAAE;EACzC,MAAMC,MAAM,GAAGD,MAAM,CAACE,CAAC,GAAGH,MAAM,CAACG,CAAC;EAClC,MAAMC,MAAM,GAAGH,MAAM,CAACI,CAAC,GAAGL,MAAM,CAACK,CAAC;EAClC,MAAMC,QAAQ,GAAGC,IAAI,CAACC,IAAI,CAACN,MAAM,GAAGA,MAAM,GAAGE,MAAM,GAAGA,MAAM,CAAC;EAC7D,OAAOE,QAAQ;AACjB;AAEA,eAAe,SAASG,WAAWA,CAACC,WAAW,EAAE;EAC/C,IAAIC,IAAI,GAAG,CAAC;EACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACAD,WAAW,CAACE,IAAI,CAAC,CAACC,CAAC,EAACC,CAAC,KAAGA,CAAC,CAACT,CAAC,GAACQ,CAAC,CAACR,CAAC,CAAC;EAChCU,OAAO,CAACC,GAAG,CAACN,WAAW,CAAC;EACxB,MAAMO,KAAK,GAAClB,iBAAiB,CAACW,WAAW,CAAC,CAAC,CAAC,EAACA,WAAW,CAAC,CAAC,CAAC,CAAC;EAC5D,MAAMQ,KAAK,GAACnB,iBAAiB,CAACW,WAAW,CAAC,CAAC,CAAC,EAACA,WAAW,CAAC,CAAC,CAAC,CAAC;EAC5DC,IAAI,GAAEM,KAAK,GAACC,KAAK;EACjBH,OAAO,CAACC,GAAG,CAACC,KAAK,EAAEC,KAAK,EAAEP,IAAI,CAAC;EAC7B,OAAOA,IAAI,GAAC,GAAG;AACjB"},"metadata":{},"sourceType":"module","externalDependencies":[]}